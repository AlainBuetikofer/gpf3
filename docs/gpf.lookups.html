
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>gpf.lookups module &#8212; gpf3 0.1.dev8+gd123c1c.d20191007 documentation</title>
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="gpf.loggers module" href="gpf.loggers.html" />
    <link rel="prev" title="gpf.cursors module" href="gpf.cursors.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gpf.loggers.html" title="gpf.loggers module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="gpf.cursors.html" title="gpf.cursors module"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">gpf3 0.1.dev8+gd123c1c.d20191007 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="gpf.html" accesskey="U">gpf package</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-gpf.lookups">
<span id="gpf-lookups-module"></span><h1>gpf.lookups module<a class="headerlink" href="#module-gpf.lookups" title="Permalink to this headline">¶</a></h1>
<p>This module can be used to build lookup data structures from Esri tables and feature classes.</p>
<dl class="method">
<dt id="gpf.lookups._process_row">
<code class="descclassname">lookups.</code><code class="descname">_process_row</code><span class="sig-paren">(</span><em>row: Sequence</em>, <em>**kwargs</em><span class="sig-paren">)</span> &#x2192; Optional[str]<a class="headerlink" href="#gpf.lookups._process_row" title="Permalink to this definition">¶</a></dt>
<dd><p>The default row processor function used by the <a class="reference internal" href="#gpf.lookups.Lookup" title="gpf.lookups.Lookup"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lookup</span></code></a> class.
Alternative row processor functions are implemented by the other lookup classes (e.g. <a class="reference internal" href="#gpf.lookups.ValueLookup" title="gpf.lookups.ValueLookup"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueLookup</span></code></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lookup</strong> – A reference to the lookup dictionary.
If the process_row() function is built in to a lookup class, <em>lookup</em> refers to <em>self</em>.</li>
<li><strong>row</strong> – The current row tuple (as returned by a <code class="xref py py-class docutils literal notranslate"><span class="pre">SearchCursor</span></code>).</li>
<li><strong>kwargs</strong> – Optional user-defined keyword arguments.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">None, str, unicode</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>This “private” function is documented here, so that users can see its signature and behaviour.
However, users should <strong>not</strong> call this function directly, but define their own functions
based on this one, using the same function signature.</p>
<p>Row processor functions directly manipulate (i.e. populate) the dictionary.
Typically, this function should at least add a key and value(s) to the <em>lookup</em> dictionary.</p>
<p class="last"><strong>A row function should always return ``None``, unless the user wants to terminate the lookup.</strong>
In that case, a failure reason (message) should be returned.</p>
</div>
</dd></dl>

<dl class="data">
<dt id="gpf.lookups.XYZ_RESOLUTION">
<code class="descclassname">gpf.lookups.</code><code class="descname">XYZ_RESOLUTION</code><em class="property"> = 0.0001</em><a class="headerlink" href="#gpf.lookups.XYZ_RESOLUTION" title="Permalink to this definition">¶</a></dt>
<dd><p>The default (Esri-recommended) resolution that is used by the <a class="reference internal" href="#gpf.lookups.get_nodekey" title="gpf.lookups.get_nodekey"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nodekey()</span></code></a> function (i.e. for lookups).
If coordinate values fall within this distance, they are considered equal.
Set this to a higher or lower value (coordinate system units) if required.</p>
</dd></dl>

<dl class="function">
<dt id="gpf.lookups.get_nodekey">
<code class="descclassname">gpf.lookups.</code><code class="descname">get_nodekey</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span> &#x2192; Tuple[int]<a class="headerlink" href="#gpf.lookups.get_nodekey" title="Permalink to this definition">¶</a></dt>
<dd><p>This function creates a hash-like tuple that can be used as a key in a <a class="reference internal" href="#gpf.lookups.RowLookup" title="gpf.lookups.RowLookup"><code class="xref py py-class docutils literal notranslate"><span class="pre">RowLookup</span></code></a> or
<a class="reference internal" href="#gpf.lookups.ValueLookup" title="gpf.lookups.ValueLookup"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueLookup</span></code></a> dictionary.
The tuple does not contain actual hashes, but consists of 2 or 3 (long) integers, which essentially are created by
dividing the coordinate values by the default resolution (0.0001) and truncating them to an integer.</p>
<p>Whenever a lookup is created using <cite>SHAPE&#64;XY</cite> or <cite>SHAPE&#64;XYZ</cite> as the <em>key_field</em>, this function is automatically
used to generate a key for the coordinate. If the user has a coordinate and wants to find the matching value(s)
in the lookup, the coordinate must be turned into a key first using this function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The number of dimensions of the coordinate must match the ones in the lookup.
In other words, when a lookup was built using 2D coordinates, the lookup key must be 2D as well.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function has been tested on 10 million random points and no duplicate keys were encountered.
However, bear in mind that 2 nearly identical coordinates might share the same key if they lie
within the default resolution distance from each other (0.0001 units e.g. meters).
If the default resolution needs to be changed, set the <code class="docutils literal notranslate"><span class="pre">XYZ_RESOLUTION</span></code> constant beforehand.</p>
</div>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coord_lookup</span> <span class="o">=</span> <span class="n">ValueLookup</span><span class="p">(</span><span class="s1">&#39;C:/Temp/test.gdb/my_points&#39;</span><span class="p">,</span> <span class="s1">&#39;SHAPE@XY&#39;</span><span class="p">,</span> <span class="s1">&#39;GlobalID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord</span> <span class="o">=</span> <span class="p">(</span><span class="mf">4.2452</span><span class="p">,</span> <span class="mf">23.24541</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="o">*</span><span class="n">coord</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="go">(42451, 232454)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coord_lookup</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="go">&#39;{628ee94d-2063-47be-b57f-8c2af6345d4e}&#39;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>args</strong> – A minimum of 2 numeric values, an EsriJSON dictionary, an ArcPy Point or PointGeometry instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="gpf.lookups.get_coordtuple">
<code class="descclassname">gpf.lookups.</code><code class="descname">get_coordtuple</code><span class="sig-paren">(</span><em>node_key: Tuple[int]</em><span class="sig-paren">)</span> &#x2192; Tuple[float]<a class="headerlink" href="#gpf.lookups.get_coordtuple" title="Permalink to this definition">¶</a></dt>
<dd><p>This function converts a node key (created by <a class="reference internal" href="#gpf.lookups.get_nodekey" title="gpf.lookups.get_nodekey"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nodekey()</span></code></a>) of integer tuples
back into a floating point coordinate X, Y(, Z) tuple.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This function should <strong>only</strong> be used to generate output for printing/logging purposes or to create
approximate coordinates. Because <a class="reference internal" href="#gpf.lookups.get_nodekey" title="gpf.lookups.get_nodekey"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nodekey()</span></code></a> truncates the coordinate, it is impossible
to get the same coordinate value back as the one that was used to create the node key, which means
that some accuracy will be lost in the process.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node_key</strong> – The node key (tuple of integers) that has to be converted.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="gpf.lookups.Lookup">
<em class="property">class </em><code class="descclassname">gpf.lookups.</code><code class="descname">Lookup</code><span class="sig-paren">(</span><em>table_path</em>, <em>key_field</em>, <em>value_field(s)</em>, <em>{where_clause}</em>, <em>{**kwargs}</em><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.Lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all lookups.</p>
<p>This class can be instantiated directly, but typically, a user would create a custom lookup class based on
this one and then override the <code class="xref py py-func docutils literal notranslate"><span class="pre">Lookup._process_row()</span></code> method.
Please refer to other implementations (<a class="reference internal" href="#gpf.lookups.RowLookup" title="gpf.lookups.RowLookup"><code class="xref py py-class docutils literal notranslate"><span class="pre">RowLookup</span></code></a>, <a class="reference internal" href="#gpf.lookups.ValueLookup" title="gpf.lookups.ValueLookup"><code class="xref py py-class docutils literal notranslate"><span class="pre">ValueLookup</span></code></a>) for concrete examples.</p>
<p><strong>Params:</strong></p>
<ul>
<li><p class="first"><strong>table_path</strong> (str, unicode):</p>
<p>Full source table or feature class path.</p>
</li>
<li><p class="first"><strong>key_field</strong> (str, unicode):</p>
<p>The field to use for the lookup dictionary keys.
If <em>SHAPE&#64;X[Y[Z]]</em> is used as the key field, the coordinates are “hashed” using the
<a class="reference internal" href="#gpf.lookups.get_nodekey" title="gpf.lookups.get_nodekey"><code class="xref py py-func docutils literal notranslate"><span class="pre">gpf.lookups.get_nodekey()</span></code></a> function.
This means, that the user should use this function as well in order to
to create a coordinate key prior to looking up the matching value for it.</p>
</li>
<li><p class="first"><strong>value_fields</strong> (list, tuple, str, unicode):</p>
<p>The field or fields to include as the lookup dictionary value(s), i.e. row.
This is the value (or tuple of values) that is returned when you perform a lookup by key.</p>
</li>
<li><p class="first"><strong>where_clause</strong> (str, unicode, <a class="reference internal" href="gpf.tools.queries.html#gpf.tools.queries.Where" title="gpf.tools.queries.Where"><code class="xref py py-class docutils literal notranslate"><span class="pre">gpf.tools.queries.Where</span></code></a>):</p>
<p>An optional where clause to filter on.</p>
</li>
</ul>
<p><strong>Keyword params:</strong></p>
<ul>
<li><p class="first"><strong>row_func</strong>:</p>
<p>If the user wishes to call the standard <cite>Lookup</cite> class but simply wants to use
a custom row processor function, you can pass in this function using the keyword <em>row_func</em>.</p>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>RuntimeError</strong> – When the lookup cannot be created or populated.</li>
<li><strong>ValueError</strong> – When a specified lookup field does not exist in the source table,
or when multiple value fields were specified.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gpf.lookups.Lookup.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None.  Remove all items from D.<a class="headerlink" href="#gpf.lookups.Lookup.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.Lookup.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; a shallow copy of D<a class="headerlink" href="#gpf.lookups.Lookup.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.Lookup.fromkeys">
<code class="descname">fromkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.Lookup.fromkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dict with keys from iterable and values equal to value.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.Lookup.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; D[k] if k in D, else d.  d defaults to None.<a class="headerlink" href="#gpf.lookups.Lookup.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.Lookup.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; a set-like object providing a view on D's items<a class="headerlink" href="#gpf.lookups.Lookup.items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.Lookup.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; a set-like object providing a view on D's keys<a class="headerlink" href="#gpf.lookups.Lookup.keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.Lookup.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; v, remove specified key and return the corresponding value.<a class="headerlink" href="#gpf.lookups.Lookup.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>If key is not found, d is returned if given, otherwise KeyError is raised</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.Lookup.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; (k, v), remove and return some (key, value) pair as a<a class="headerlink" href="#gpf.lookups.Lookup.popitem" title="Permalink to this definition">¶</a></dt>
<dd><p>2-tuple; but raise KeyError if D is empty.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.Lookup.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; D.get(k,d), also set D[k]=d if k not in D<a class="headerlink" href="#gpf.lookups.Lookup.setdefault" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.Lookup.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>E</em>, <span class="optional">]</span><em>**F</em><span class="sig-paren">)</span> &#x2192; None.  Update D from dict/iterable E and F.<a class="headerlink" href="#gpf.lookups.Lookup.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
In either case, this is followed by: for k in F:  D[k] = F[k]</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.Lookup.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; an object providing a view on D's values<a class="headerlink" href="#gpf.lookups.Lookup.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="gpf.lookups.ValueLookup">
<em class="property">class </em><code class="descclassname">gpf.lookups.</code><code class="descname">ValueLookup</code><span class="sig-paren">(</span><em>table_path</em>, <em>key_field</em>, <em>value_field</em>, <em>{where_clause}</em>, <em>{duplicate_keys}</em><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueLookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a lookup dictionary from a given source table or feature class.
ValueLookup inherits from <code class="docutils literal notranslate"><span class="pre">dict</span></code>, so all the built-in dictionary functions
(<a class="reference internal" href="#gpf.lookups.ValueLookup.update" title="gpf.lookups.ValueLookup.update"><code class="xref py py-func docutils literal notranslate"><span class="pre">update()</span></code></a>, <a class="reference internal" href="#gpf.lookups.ValueLookup.items" title="gpf.lookups.ValueLookup.items"><code class="xref py py-func docutils literal notranslate"><span class="pre">items()</span></code></a> etc.) are available.</p>
<p>When an empty key (<code class="docutils literal notranslate"><span class="pre">None</span></code>) is encountered, the key-value pair will be discarded.</p>
<p><strong>Params:</strong></p>
<ul>
<li><p class="first"><strong>table_path</strong> (str, unicode):</p>
<p>Full source table or feature class path.</p>
</li>
<li><p class="first"><strong>key_field</strong> (str, unicode):</p>
<p>The field to use for the ValueLookup dictionary keys.
If <em>SHAPE&#64;X[Y[Z]]</em> is used as the key field, the coordinates are “hashed” using the
<a class="reference internal" href="#gpf.lookups.get_nodekey" title="gpf.lookups.get_nodekey"><code class="xref py py-func docutils literal notranslate"><span class="pre">gpf.lookups.get_nodekey()</span></code></a> function.
This means, that the user should use this function as well in order to
to create a coordinate key prior to looking up the matching value for it.</p>
</li>
<li><p class="first"><strong>value_field</strong> (str, unicode):</p>
<p>The single field to include in the ValueLookup dictionary value.
This is the value that is returned when you perform a lookup by key.</p>
</li>
<li><p class="first"><strong>where_clause</strong> (str, unicode, <a class="reference internal" href="gpf.tools.queries.html#gpf.tools.queries.Where" title="gpf.tools.queries.Where"><code class="xref py py-class docutils literal notranslate"><span class="pre">gpf.tools.queries.Where</span></code></a>):</p>
<p>An optional where clause to filter the table.</p>
</li>
</ul>
<p><strong>Keyword params:</strong></p>
<ul>
<li><p class="first"><strong>duplicate_keys</strong> (bool):</p>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the ValueLookup allows for duplicate keys in the input.
The dictionary values will become <strong>lists</strong> of values instead of a <strong>single</strong> value.
Please note that actual duplicate checks will not be performed. This means, that
when <em>duplicate_keys</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code> and duplicates <em>are</em> encountered,
the last existing key-value pair will be overwritten.</p>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>RuntimeError</strong> – When the lookup cannot be created or populated.</li>
<li><strong>ValueError</strong> – When a specified lookup field does not exist in the source table,
or when multiple value fields were specified.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">When multiple fields should be stored in the lookup,
the <a class="reference internal" href="#gpf.lookups.RowLookup" title="gpf.lookups.RowLookup"><code class="xref py py-class docutils literal notranslate"><span class="pre">gpf.lookups.RowLookup</span></code></a> class should be used instead.</p>
</div>
<dl class="method">
<dt id="gpf.lookups.ValueLookup.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None.  Remove all items from D.<a class="headerlink" href="#gpf.lookups.ValueLookup.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueLookup.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; a shallow copy of D<a class="headerlink" href="#gpf.lookups.ValueLookup.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueLookup.fromkeys">
<code class="descname">fromkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueLookup.fromkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dict with keys from iterable and values equal to value.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueLookup.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; D[k] if k in D, else d.  d defaults to None.<a class="headerlink" href="#gpf.lookups.ValueLookup.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueLookup.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; a set-like object providing a view on D's items<a class="headerlink" href="#gpf.lookups.ValueLookup.items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueLookup.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; a set-like object providing a view on D's keys<a class="headerlink" href="#gpf.lookups.ValueLookup.keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueLookup.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; v, remove specified key and return the corresponding value.<a class="headerlink" href="#gpf.lookups.ValueLookup.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>If key is not found, d is returned if given, otherwise KeyError is raised</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueLookup.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; (k, v), remove and return some (key, value) pair as a<a class="headerlink" href="#gpf.lookups.ValueLookup.popitem" title="Permalink to this definition">¶</a></dt>
<dd><p>2-tuple; but raise KeyError if D is empty.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueLookup.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; D.get(k,d), also set D[k]=d if k not in D<a class="headerlink" href="#gpf.lookups.ValueLookup.setdefault" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueLookup.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>E</em>, <span class="optional">]</span><em>**F</em><span class="sig-paren">)</span> &#x2192; None.  Update D from dict/iterable E and F.<a class="headerlink" href="#gpf.lookups.ValueLookup.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
In either case, this is followed by: for k in F:  D[k] = F[k]</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueLookup.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; an object providing a view on D's values<a class="headerlink" href="#gpf.lookups.ValueLookup.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="gpf.lookups.RowLookup">
<em class="property">class </em><code class="descclassname">gpf.lookups.</code><code class="descname">RowLookup</code><span class="sig-paren">(</span><em>table_path</em>, <em>key_field</em>, <em>value_fields</em>, <em>{where_clause}</em>, <em>{duplicate_keys}</em>, <em>{mutable_values}</em><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.RowLookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a lookup dictionary from a given table or feature class.
RowLookup inherits from <code class="docutils literal notranslate"><span class="pre">dict</span></code>, so all the built-in dictionary functions
(<a class="reference internal" href="#gpf.lookups.RowLookup.update" title="gpf.lookups.RowLookup.update"><code class="xref py py-func docutils literal notranslate"><span class="pre">update()</span></code></a>, <a class="reference internal" href="#gpf.lookups.RowLookup.items" title="gpf.lookups.RowLookup.items"><code class="xref py py-func docutils literal notranslate"><span class="pre">items()</span></code></a> etc.) are available.</p>
<p>When an empty key (<code class="docutils literal notranslate"><span class="pre">None</span></code>) is encountered, the key-values pair will be discarded.</p>
<p><strong>Params:</strong></p>
<ul>
<li><p class="first"><strong>table_path</strong> (str, unicode):</p>
<p>Full source table or feature class path.</p>
</li>
<li><p class="first"><strong>key_field</strong> (str, unicode):</p>
<p>The field to use for the RowLookup dictionary keys.
If <em>SHAPE&#64;X[Y[Z]]</em> is used as the key field, the coordinates are “hashed” using the
<code class="xref py py-func docutils literal notranslate"><span class="pre">gpf.tools.lookup.get_nodekey()</span></code> function.
This means, that the user should use this function as well in order to
to create a coordinate key prior to looking up the matching values for it.</p>
</li>
<li><p class="first"><strong>value_field</strong> (str, unicode):</p>
<p>The fields to include in the RowLookup dictionary values.
These are the values that are returned when you perform a lookup by key.</p>
</li>
<li><p class="first"><strong>where_clause</strong> (str, unicode, <a class="reference internal" href="gpf.tools.queries.html#gpf.tools.queries.Where" title="gpf.tools.queries.Where"><code class="xref py py-class docutils literal notranslate"><span class="pre">gpf.tools.queries.Where</span></code></a>):</p>
<p>An optional where clause to filter the table.</p>
</li>
</ul>
<p><strong>Keyword params:</strong></p>
<ul>
<li><p class="first"><strong>duplicate_keys</strong> (bool):</p>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the RowLookup allows for duplicate keys in the input.
The values will become <strong>lists</strong> of tuples/lists instead of a <strong>single</strong> tuple/list.
Please note that duplicate checks will not actually be performed. This means, that
when <em>duplicate_keys</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code> and duplicates are encountered,
the last existing key-value pair will be simply overwritten.</p>
</li>
<li><p class="first"><strong>mutable_values</strong> (bool):</p>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the RowLookup values are stored as <code class="docutils literal notranslate"><span class="pre">list</span></code> objects.
These are mutable, which means that you can change the values or add new ones.
The default is <code class="docutils literal notranslate"><span class="pre">False</span></code>, which causes the RowLookup values to become <code class="docutils literal notranslate"><span class="pre">tuple</span></code> objects.
These are immutable, which consumes less memory and allows for faster retrieval.</p>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li><strong>RuntimeError</strong> – When the lookup cannot be created or populated.</li>
<li><strong>ValueError</strong> – When a specified lookup field does not exist in the source table,
or when a single value field was specified.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">When a single field value should be stored in the lookup,
the <a class="reference internal" href="#gpf.lookups.ValueLookup" title="gpf.lookups.ValueLookup"><code class="xref py py-class docutils literal notranslate"><span class="pre">gpf.lookups.ValueLookup</span></code></a> class should be used instead.</p>
</div>
<dl class="method">
<dt id="gpf.lookups.RowLookup.get_value">
<code class="descname">get_value</code><span class="sig-paren">(</span><em>key</em>, <em>field</em>, <em>default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.RowLookup.get_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Looks up a value by key for one specific field.
This function can be convenient when only a single value needs to be retrieved from the lookup.
The difference with the built-in <a class="reference internal" href="#gpf.lookups.RowLookup.get" title="gpf.lookups.RowLookup.get"><code class="xref py py-func docutils literal notranslate"><span class="pre">get()</span></code></a> method is, that the <a class="reference internal" href="#gpf.lookups.RowLookup.get_value" title="gpf.lookups.RowLookup.get_value"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_value()</span></code></a> function
returns a single value, whereas the other one returns a list or tuple of values (i.e. row).</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_lookup</span> <span class="o">=</span> <span class="n">RowLookup</span><span class="p">(</span><span class="s1">&#39;C:/Temp/test.gdb/my_table&#39;</span><span class="p">,</span> <span class="s1">&#39;GlobalID&#39;</span><span class="p">,</span> <span class="s1">&#39;Field1&#39;</span><span class="p">,</span> <span class="s1">&#39;Field2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Traditional approach to print Field1:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">my_lookup</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;{628ee94d-2063-47be-b57f-8c2af6345d4e}&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">values</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">&#39;ThisIsTheValueOfField1&#39;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Alternative traditional approach to print Field1:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">field1</span><span class="p">,</span> <span class="n">field2</span> <span class="o">=</span> <span class="n">my_lookup</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;{628ee94d-2063-47be-b57f-8c2af6345d4e}&#39;</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">field1</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">field1</span><span class="p">)</span>
<span class="go">&#39;ThisIsTheValueOfField1&#39;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Approach using the get_value() function:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">my_lookup</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s1">&#39;{628ee94d-2063-47be-b57f-8c2af6345d4e}&#39;</span><span class="p">,</span> <span class="s1">&#39;Field1&#39;</span><span class="p">))</span>
<span class="go">&#39;ThisIsTheValueOfField1&#39;</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> – Key to find in the lookup dictionary.</li>
<li><strong>field</strong> – The field name (as used during initialization of the lookup) for which to retrieve the value.</li>
<li><strong>default</strong> – The value to return when the value was not found. Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; None.  Remove all items from D.<a class="headerlink" href="#gpf.lookups.RowLookup.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; a shallow copy of D<a class="headerlink" href="#gpf.lookups.RowLookup.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.fromkeys">
<code class="descname">fromkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.RowLookup.fromkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new dict with keys from iterable and values equal to value.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; D[k] if k in D, else d.  d defaults to None.<a class="headerlink" href="#gpf.lookups.RowLookup.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; a set-like object providing a view on D's items<a class="headerlink" href="#gpf.lookups.RowLookup.items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; a set-like object providing a view on D's keys<a class="headerlink" href="#gpf.lookups.RowLookup.keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; v, remove specified key and return the corresponding value.<a class="headerlink" href="#gpf.lookups.RowLookup.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>If key is not found, d is returned if given, otherwise KeyError is raised</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; (k, v), remove and return some (key, value) pair as a<a class="headerlink" href="#gpf.lookups.RowLookup.popitem" title="Permalink to this definition">¶</a></dt>
<dd><p>2-tuple; but raise KeyError if D is empty.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; D.get(k,d), also set D[k]=d if k not in D<a class="headerlink" href="#gpf.lookups.RowLookup.setdefault" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>E</em>, <span class="optional">]</span><em>**F</em><span class="sig-paren">)</span> &#x2192; None.  Update D from dict/iterable E and F.<a class="headerlink" href="#gpf.lookups.RowLookup.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
In either case, this is followed by: for k in F:  D[k] = F[k]</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.RowLookup.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; an object providing a view on D's values<a class="headerlink" href="#gpf.lookups.RowLookup.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="gpf.lookups.NodeSet">
<em class="property">class </em><code class="descclassname">gpf.lookups.</code><code class="descname">NodeSet</code><span class="sig-paren">(</span><em>fc_path: str</em>, <em>where_clause: Union[None</em>, <em>str</em>, <em>gpf.tools.queries.Where] = None</em>, <em>all_vertices: bool = False</em><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a set of unique node keys for coordinates in a feature class.
The <a class="reference internal" href="#gpf.lookups.get_nodekey" title="gpf.lookups.get_nodekey"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_nodekey()</span></code></a> function will be used to generate the coordinate hash.
When the feature class is Z aware, the node keys will be 3D as well.
Note that in all cases, M will be ignored.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">NodeSet</span></code> inherits all methods from the built-in Python <code class="docutils literal notranslate"><span class="pre">set</span></code>.</p>
<p>For feature classes with a geometry type other than Point, a NodeSet will be built from the first and last
points in a geometry. If this is not desired (i.e. all coordinates should be included), the user should set
the <em>all_vertices</em> option to <code class="docutils literal notranslate"><span class="pre">True</span></code>.
An exception to this behavior is the Multipoint geometry: for this type, all coordinates will always be included.</p>
<p><strong>Params:</strong></p>
<ul>
<li><p class="first"><strong>fc_path</strong> (str):</p>
<p>The full path to the feature class.</p>
</li>
<li><p class="first"><strong>where_clause</strong> (str, unicode, gpf.tools.queries.Where):</p>
<p>An optional where clause to filter the feature class.</p>
</li>
<li><p class="first"><strong>all_vertices</strong> (bool):</p>
<p>Defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code>. When set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, all geometry coordinates are included.
Otherwise, only the first and/or last points are considered.</p>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><strong>ValueError</strong> – If the input dataset is not a feature class or if the geometry type is MultiPatch.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="gpf.lookups.NodeSet.add">
<code class="descname">add</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an element to a set.</p>
<p>This has no effect if the element is already present.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all elements from this set.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shallow copy of a set.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.difference">
<code class="descname">difference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the difference of two or more sets as a new set.</p>
<p>(i.e. all elements that are in this set but not the others.)</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.difference_update">
<code class="descname">difference_update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.difference_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all elements of another set from this set.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.discard">
<code class="descname">discard</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.discard" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an element from a set if it is a member.</p>
<p>If the element is not a member, do nothing.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection of two sets as a new set.</p>
<p>(i.e. all elements that are in both sets.)</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.intersection_update">
<code class="descname">intersection_update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.intersection_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update a set with the intersection of itself and another.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.isdisjoint">
<code class="descname">isdisjoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.isdisjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if two sets have a null intersection.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.issubset">
<code class="descname">issubset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.issubset" title="Permalink to this definition">¶</a></dt>
<dd><p>Report whether another set contains this set.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.issuperset">
<code class="descname">issuperset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.issuperset" title="Permalink to this definition">¶</a></dt>
<dd><p>Report whether this set contains another set.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove and return an arbitrary set element.
Raises KeyError if the set is empty.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.remove">
<code class="descname">remove</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove an element from a set; it must be a member.</p>
<p>If the element is not a member, raise a KeyError.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.symmetric_difference">
<code class="descname">symmetric_difference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.symmetric_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the symmetric difference of two sets as a new set.</p>
<p>(i.e. all elements that are in exactly one of the sets.)</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.symmetric_difference_update">
<code class="descname">symmetric_difference_update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.symmetric_difference_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update a set with the symmetric difference of itself and another.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.union">
<code class="descname">union</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the union of sets as a new set.</p>
<p>(i.e. all elements that are in either set.)</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.NodeSet.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.NodeSet.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update a set with the union of itself and others.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="gpf.lookups.ValueSet">
<em class="property">class </em><code class="descclassname">gpf.lookups.</code><code class="descname">ValueSet</code><span class="sig-paren">(</span><em>table_path</em>, <em>field</em>, <em>where_clause=None</em><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a set of unique values for a single column in a feature class or table.
This class inherits all methods from the built-in Python <code class="docutils literal notranslate"><span class="pre">frozenset</span></code>.</p>
<p><strong>Params:</strong></p>
<ul>
<li><p class="first"><strong>table_path</strong> (str):</p>
<p>The full path to the table or feature class.</p>
</li>
<li><p class="first"><strong>field</strong> (str):</p>
<p>The field name for which to collect a set of unique values.</p>
</li>
<li><p class="first"><strong>where_clause</strong> (str, gpf.tools.queries.Where):</p>
<p>An optional where clause to filter the feature class.</p>
</li>
</ul>
<dl class="method">
<dt id="gpf.lookups.ValueSet.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueSet.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shallow copy of a set.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueSet.difference">
<code class="descname">difference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueSet.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the difference of two or more sets as a new set.</p>
<p>(i.e. all elements that are in this set but not the others.)</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueSet.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueSet.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection of two sets as a new set.</p>
<p>(i.e. all elements that are in both sets.)</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueSet.isdisjoint">
<code class="descname">isdisjoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueSet.isdisjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Return True if two sets have a null intersection.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueSet.issubset">
<code class="descname">issubset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueSet.issubset" title="Permalink to this definition">¶</a></dt>
<dd><p>Report whether another set contains this set.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueSet.issuperset">
<code class="descname">issuperset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueSet.issuperset" title="Permalink to this definition">¶</a></dt>
<dd><p>Report whether this set contains another set.</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueSet.symmetric_difference">
<code class="descname">symmetric_difference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueSet.symmetric_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the symmetric difference of two sets as a new set.</p>
<p>(i.e. all elements that are in exactly one of the sets.)</p>
</dd></dl>

<dl class="method">
<dt id="gpf.lookups.ValueSet.union">
<code class="descname">union</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#gpf.lookups.ValueSet.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the union of sets as a new set.</p>
<p>(i.e. all elements that are in either set.)</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="gpf.cursors.html"
                        title="previous chapter">gpf.cursors module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="gpf.loggers.html"
                        title="next chapter">gpf.loggers module</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/gpf.lookups.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gpf.loggers.html" title="gpf.loggers module"
             >next</a> |</li>
        <li class="right" >
          <a href="gpf.cursors.html" title="gpf.cursors module"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">gpf3 0.1.dev8+gd123c1c.d20191007 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="gpf.html" >gpf package</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Geocom Informatik AG / VertiGIS, Burgdorf, Switzerland.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>