

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gpf.lookups &mdash; gpf3 0.1.dev8+gd123c1c.d20191007 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> gpf3
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../gpf.html">gpf package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">gpf3</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>gpf.lookups</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gpf.lookups</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1">#</span>
<span class="c1"># Copyright 2019 Geocom Informatik AG / VertiGIS</span>

<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>

<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module can be used to build lookup data structures from Esri tables and feature classes.</span>

<span class="sd">.. automethod:: gpf.lookups._process_row</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">_tp</span>

<span class="kn">import</span> <span class="nn">gpf.common.const</span> <span class="k">as</span> <span class="nn">_const</span>
<span class="kn">import</span> <span class="nn">gpf.common.textutils</span> <span class="k">as</span> <span class="nn">_tu</span>
<span class="kn">import</span> <span class="nn">gpf.common.validate</span> <span class="k">as</span> <span class="nn">_vld</span>
<span class="kn">import</span> <span class="nn">gpf.cursors</span> <span class="k">as</span> <span class="nn">_cursors</span>
<span class="kn">import</span> <span class="nn">gpf.tools.geometry</span> <span class="k">as</span> <span class="nn">_geo</span>
<span class="kn">import</span> <span class="nn">gpf.tools.metadata</span> <span class="k">as</span> <span class="nn">_meta</span>
<span class="kn">import</span> <span class="nn">gpf.tools.queries</span> <span class="k">as</span> <span class="nn">_q</span>

<span class="n">_DUPEKEYS_ARG</span> <span class="o">=</span> <span class="s1">&#39;duplicate_keys&#39;</span>
<span class="n">_MUTABLE_ARG</span> <span class="o">=</span> <span class="s1">&#39;mutable_values&#39;</span>
<span class="n">_ROWFUNC_ARG</span> <span class="o">=</span> <span class="s1">&#39;row_func&#39;</span>

<span class="c1">#: The default (Esri-recommended) resolution that is used by the :func:`get_nodekey` function (i.e. for lookups).</span>
<span class="c1">#: If coordinate values fall within this distance, they are considered equal.</span>
<span class="c1">#: Set this to a higher or lower value (coordinate system units) if required.</span>
<span class="n">XYZ_RESOLUTION</span> <span class="o">=</span> <span class="mf">0.0001</span>


<div class="viewcode-block" id="get_nodekey"><a class="viewcode-back" href="../../gpf.lookups.html#gpf.get_nodekey">[docs]</a><span class="k">def</span> <span class="nf">get_nodekey</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function creates a hash-like tuple that can be used as a key in a :class:`RowLookup` or</span>
<span class="sd">    :class:`ValueLookup` dictionary.</span>
<span class="sd">    The tuple does not contain actual hashes, but consists of 2 or 3 (long) integers, which essentially are created by</span>
<span class="sd">    dividing the coordinate values by the default resolution (0.0001) and truncating them to an integer.</span>

<span class="sd">    Whenever a lookup is created using `SHAPE@XY` or `SHAPE@XYZ` as the *key_field*, this function is automatically</span>
<span class="sd">    used to generate a key for the coordinate. If the user has a coordinate and wants to find the matching value(s)</span>
<span class="sd">    in the lookup, the coordinate must be turned into a key first using this function.</span>

<span class="sd">    .. note::       The number of dimensions of the coordinate must match the ones in the lookup.</span>
<span class="sd">                    In other words, when a lookup was built using 2D coordinates, the lookup key must be 2D as well.</span>

<span class="sd">    .. warning::    This function has been tested on 10 million random points and no duplicate keys were encountered.</span>
<span class="sd">                    However, bear in mind that 2 nearly identical coordinates might share the same key if they lie</span>
<span class="sd">                    within the default resolution distance from each other (0.0001 units e.g. meters).</span>
<span class="sd">                    If the default resolution needs to be changed, set the ``XYZ_RESOLUTION`` constant beforehand.</span>

<span class="sd">    Example:</span>

<span class="sd">        &gt;&gt;&gt; coord_lookup = ValueLookup(&#39;C:/Temp/test.gdb/my_points&#39;, &#39;SHAPE@XY&#39;, &#39;GlobalID&#39;)</span>
<span class="sd">        &gt;&gt;&gt; coord = (4.2452, 23.24541)</span>
<span class="sd">        &gt;&gt;&gt; key = key(*coord)</span>
<span class="sd">        &gt;&gt;&gt; print(key)</span>
<span class="sd">        (42451, 232454)</span>
<span class="sd">        &gt;&gt;&gt; coord_lookup.get(key)</span>
<span class="sd">        &#39;{628ee94d-2063-47be-b57f-8c2af6345d4e}&#39;</span>

<span class="sd">    :param args:    A minimum of 2 numeric values, an EsriJSON dictionary, an ArcPy Point or PointGeometry instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span> <span class="o">/</span> <span class="n">XYZ_RESOLUTION</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_geo</span><span class="o">.</span><span class="n">get_xyz</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_coordtuple"><a class="viewcode-back" href="../../gpf.lookups.html#gpf.get_coordtuple">[docs]</a><span class="k">def</span> <span class="nf">get_coordtuple</span><span class="p">(</span><span class="n">node_key</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function converts a node key (created by :func:`get_nodekey`) of integer tuples</span>
<span class="sd">    back into a floating point coordinate X, Y(, Z) tuple.</span>

<span class="sd">    .. warning::    This function should **only** be used to generate output for printing/logging purposes or to create</span>
<span class="sd">                    approximate coordinates. Because :func:`get_nodekey` truncates the coordinate, it is impossible</span>
<span class="sd">                    to get the same coordinate value back as the one that was used to create the node key, which means</span>
<span class="sd">                    that some accuracy will be lost in the process.</span>

<span class="sd">    :param node_key:    The node key (tuple of integers) that has to be converted.</span>
<span class="sd">    :rtype:             tuple</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">v</span> <span class="o">*</span> <span class="n">XYZ_RESOLUTION</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_key</span><span class="p">)</span></div>


<span class="c1"># noinspection PyUnusedLocal</span>
<span class="k">def</span> <span class="nf">_process_row</span><span class="p">(</span><span class="n">lookup</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">row</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Sequence</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The default row processor function used by the :class:`Lookup` class.</span>
<span class="sd">    Alternative row processor functions are implemented by the other lookup classes (e.g. :class:`ValueLookup`).</span>

<span class="sd">    :param lookup:  A reference to the lookup dictionary.</span>
<span class="sd">                    If the process_row() function is built in to a lookup class, *lookup* refers to *self*.</span>
<span class="sd">    :param row:     The current row tuple (as returned by a :class:`SearchCursor`).</span>
<span class="sd">    :param kwargs:  Optional user-defined keyword arguments.</span>
<span class="sd">    :rtype:         None, str, unicode</span>

<span class="sd">    .. note::       This &quot;private&quot; function is documented here, so that users can see its signature and behaviour.</span>
<span class="sd">                    However, users should **not** call this function directly, but define their own functions</span>
<span class="sd">                    based on this one, using the same function signature.</span>

<span class="sd">                    Row processor functions directly manipulate (i.e. populate) the dictionary.</span>
<span class="sd">                    Typically, this function should at least add a key and value(s) to the *lookup* dictionary.</span>

<span class="sd">                    **A row function should always return ``None``, unless the user wants to terminate the lookup.**</span>
<span class="sd">                    In that case, a failure reason (message) should be returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">key</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">lookup</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>


<div class="viewcode-block" id="Lookup"><a class="viewcode-back" href="../../gpf.lookups.html#gpf.Lookup">[docs]</a><span class="k">class</span> <span class="nc">Lookup</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lookup(table_path, key_field, value_field(s), {where_clause}, {**kwargs})</span>

<span class="sd">    Base class for all lookups.</span>

<span class="sd">    This class can be instantiated directly, but typically, a user would create a custom lookup class based on</span>
<span class="sd">    this one and then override the :func:`Lookup._process_row` method.</span>
<span class="sd">    Please refer to other implementations (:class:`RowLookup`, :class:`ValueLookup`) for concrete examples.</span>

<span class="sd">    **Params:**</span>

<span class="sd">    -   **table_path** (str, unicode):</span>

<span class="sd">        Full source table or feature class path.</span>

<span class="sd">    -   **key_field** (str, unicode):</span>

<span class="sd">        The field to use for the lookup dictionary keys.</span>
<span class="sd">        If *SHAPE@X[Y[Z]]* is used as the key field, the coordinates are &quot;hashed&quot; using the</span>
<span class="sd">        :func:`gpf.lookups.get_nodekey` function.</span>
<span class="sd">        This means, that the user should use this function as well in order to</span>
<span class="sd">        to create a coordinate key prior to looking up the matching value for it.</span>

<span class="sd">    -   **value_fields** (list, tuple, str, unicode):</span>

<span class="sd">        The field or fields to include as the lookup dictionary value(s), i.e. row.</span>
<span class="sd">        This is the value (or tuple of values) that is returned when you perform a lookup by key.</span>

<span class="sd">    -   **where_clause** (str, unicode, :class:`gpf.tools.queries.Where`):</span>

<span class="sd">        An optional where clause to filter on.</span>

<span class="sd">    **Keyword params:**</span>

<span class="sd">    -   **row_func**:</span>

<span class="sd">        If the user wishes to call the standard `Lookup` class but simply wants to use</span>
<span class="sd">        a custom row processor function, you can pass in this function using the keyword *row_func*.</span>

<span class="sd">    :raises RuntimeError:       When the lookup cannot be created or populated.</span>
<span class="sd">    :raises ValueError:         When a specified lookup field does not exist in the source table,</span>
<span class="sd">                                or when multiple value fields were specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key_field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value_fields</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                 <span class="n">where_clause</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">_q</span><span class="o">.</span><span class="n">Where</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">key_field</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">value_fields</span> <span class="k">if</span> <span class="n">_vld</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">value_fields</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">value_fields</span><span class="p">,</span> <span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hascoordkey</span> <span class="o">=</span> <span class="n">key_field</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">FIELD_X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populate</span><span class="p">(</span><span class="n">table_path</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">where_clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_fields</span><span class="p">(</span><span class="n">table_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_tp</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets all field names in the table.</span>

<span class="sd">        :raises RuntimeError:   When the table metadata could not be retrieved.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">_meta</span><span class="o">.</span><span class="n">Describe</span><span class="p">(</span><span class="n">table_path</span><span class="p">)</span>
        <span class="n">_vld</span><span class="o">.</span><span class="n">pass_if</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="ne">RuntimeError</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;Failed to create lookup for {_tu.to_repr(table_path)}&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">desc</span><span class="o">.</span><span class="n">get_fields</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_fields</span><span class="p">(</span><span class="n">user_fields</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">table_fields</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the given *user_fields* exist in *table_fields*.</span>

<span class="sd">        :raises ValueError: When a field does not exist in the source table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">user_fields</span><span class="p">:</span>
            <span class="n">_vld</span><span class="o">.</span><span class="n">pass_if</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">CHAR_AT</span> <span class="ow">in</span> <span class="n">field</span> <span class="ow">or</span> <span class="n">field</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="n">table_fields</span><span class="p">,</span>
                         <span class="ne">ValueError</span><span class="p">,</span> <span class="s1">&#39;Field </span><span class="si">{}</span><span class="s1"> does not exist&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_has_self</span><span class="p">(</span><span class="n">row_func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Checks if `func` is an instance method or function and checks if it&#39;s a valid row processor. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_vld</span><span class="o">.</span><span class="n">signature_matches</span><span class="p">(</span><span class="n">row_func</span><span class="p">,</span> <span class="n">Lookup</span><span class="o">.</span><span class="n">_process_row</span><span class="p">):</span>
            <span class="c1"># row_func is an instance method (signature matches the default self._process_row())</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">_vld</span><span class="o">.</span><span class="n">signature_matches</span><span class="p">(</span><span class="n">row_func</span><span class="p">,</span> <span class="n">_process_row</span><span class="p">):</span>
            <span class="c1"># row_func is a regular function (signature matches _process_row())</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Row processor function has a bad signature&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Instance method version of the :func:`_process_row` module function. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_process_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_populate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_path</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">where_clause</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Populates the lookup with data, calling _process_row() on each row returned by the SearchCursor. &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Validate fields</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_fields</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fields</span><span class="p">(</span><span class="n">table_path</span><span class="p">))</span>

            <span class="c1"># Validate row processor function (if any)</span>
            <span class="n">row_func</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_ROWFUNC_ARG</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_row</span><span class="p">)</span>
            <span class="n">has_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_self</span><span class="p">(</span><span class="n">row_func</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">_cursors</span><span class="o">.</span><span class="n">SearchCursor</span><span class="p">(</span><span class="n">table_path</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">where_clause</span><span class="p">)</span> <span class="k">as</span> <span class="n">rows</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                    <span class="n">failed</span> <span class="o">=</span> <span class="n">row_func</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_self</span> <span class="k">else</span> <span class="n">row_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">failed</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Failed to create </span><span class="si">{}</span><span class="s1"> for </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                                       <span class="n">_tu</span><span class="o">.</span><span class="n">to_repr</span><span class="p">(</span><span class="n">table_path</span><span class="p">),</span> <span class="n">e</span><span class="p">))</span></div>


<div class="viewcode-block" id="ValueLookup"><a class="viewcode-back" href="../../gpf.lookups.html#gpf.ValueLookup">[docs]</a><span class="k">class</span> <span class="nc">ValueLookup</span><span class="p">(</span><span class="n">Lookup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ValueLookup(table_path, key_field, value_field, {where_clause}, {duplicate_keys})</span>

<span class="sd">    Creates a lookup dictionary from a given source table or feature class.</span>
<span class="sd">    ValueLookup inherits from ``dict``, so all the built-in dictionary functions</span>
<span class="sd">    (:func:`update`, :func:`items` etc.) are available.</span>

<span class="sd">    When an empty key (``None``) is encountered, the key-value pair will be discarded.</span>

<span class="sd">    **Params:**</span>

<span class="sd">    -   **table_path** (str, unicode):</span>

<span class="sd">        Full source table or feature class path.</span>

<span class="sd">    -   **key_field** (str, unicode):</span>

<span class="sd">        The field to use for the ValueLookup dictionary keys.</span>
<span class="sd">        If *SHAPE@X[Y[Z]]* is used as the key field, the coordinates are &quot;hashed&quot; using the</span>
<span class="sd">        :func:`gpf.lookups.get_nodekey` function.</span>
<span class="sd">        This means, that the user should use this function as well in order to</span>
<span class="sd">        to create a coordinate key prior to looking up the matching value for it.</span>

<span class="sd">    -   **value_field** (str, unicode):</span>

<span class="sd">        The single field to include in the ValueLookup dictionary value.</span>
<span class="sd">        This is the value that is returned when you perform a lookup by key.</span>

<span class="sd">    -   **where_clause** (str, unicode, :class:`gpf.tools.queries.Where`):</span>

<span class="sd">        An optional where clause to filter the table.</span>

<span class="sd">    **Keyword params:**</span>

<span class="sd">    -   **duplicate_keys** (bool):</span>

<span class="sd">        If ``True``, the ValueLookup allows for duplicate keys in the input.</span>
<span class="sd">        The dictionary values will become **lists** of values instead of a **single** value.</span>
<span class="sd">        Please note that actual duplicate checks will not be performed. This means, that</span>
<span class="sd">        when *duplicate_keys* is ``False`` and duplicates *are* encountered,</span>
<span class="sd">        the last existing key-value pair will be overwritten.</span>

<span class="sd">    :raises RuntimeError:       When the lookup cannot be created or populated.</span>
<span class="sd">    :raises ValueError:         When a specified lookup field does not exist in the source table,</span>
<span class="sd">                                or when multiple value fields were specified.</span>

<span class="sd">    .. seealso::                When multiple fields should be stored in the lookup,</span>
<span class="sd">                                the :class:`gpf.lookups.RowLookup` class should be used instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key_field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value_field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">where_clause</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">_q</span><span class="o">.</span><span class="n">Where</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_vld</span><span class="o">.</span><span class="n">raise_if</span><span class="p">(</span><span class="n">_vld</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">value_field</span><span class="p">),</span> <span class="ne">ValueError</span><span class="p">,</span>
                      <span class="n">f</span><span class="s1">&#39;</span><span class="si">{ValueLookup.__name__}</span><span class="s1"> expects a single value field: use </span><span class="si">{RowLookup.__name__}</span><span class="s1"> instead&#39;</span><span class="p">)</span>
        <span class="n">_vld</span><span class="o">.</span><span class="n">pass_if</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">_vld</span><span class="o">.</span><span class="n">has_value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">table_path</span><span class="p">,</span> <span class="n">key_field</span><span class="p">,</span> <span class="n">value_field</span><span class="p">)),</span> <span class="ne">ValueError</span><span class="p">,</span>
                     <span class="n">f</span><span class="s1">&#39;</span><span class="si">{ValueLookup.__name__}</span><span class="s1"> requires valid table_path, key_field and value_field arguments&#39;</span><span class="p">)</span>

        <span class="c1"># User cannot override row processor function for this class</span>
        <span class="k">if</span> <span class="n">_ROWFUNC_ARG</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">_ROWFUNC_ARG</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dupekeys</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_DUPEKEYS_ARG</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ValueLookup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">table_path</span><span class="p">,</span> <span class="n">key_field</span><span class="p">,</span> <span class="n">value_field</span><span class="p">,</span> <span class="n">where_clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Row processor function override. &quot;&quot;&quot;</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">row</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hascoordkey</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">get_nodekey</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dupekeys</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="RowLookup"><a class="viewcode-back" href="../../gpf.lookups.html#gpf.RowLookup">[docs]</a><span class="k">class</span> <span class="nc">RowLookup</span><span class="p">(</span><span class="n">Lookup</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RowLookup(table_path, key_field, value_fields, {where_clause}, {duplicate_keys}, {mutable_values})</span>

<span class="sd">    Creates a lookup dictionary from a given table or feature class.</span>
<span class="sd">    RowLookup inherits from ``dict``, so all the built-in dictionary functions</span>
<span class="sd">    (:func:`update`, :func:`items` etc.) are available.</span>

<span class="sd">    When an empty key (``None``) is encountered, the key-values pair will be discarded.</span>

<span class="sd">    **Params:**</span>

<span class="sd">    -   **table_path** (str, unicode):</span>

<span class="sd">        Full source table or feature class path.</span>

<span class="sd">    -   **key_field** (str, unicode):</span>

<span class="sd">        The field to use for the RowLookup dictionary keys.</span>
<span class="sd">        If *SHAPE@X[Y[Z]]* is used as the key field, the coordinates are &quot;hashed&quot; using the</span>
<span class="sd">        :func:`gpf.tools.lookup.get_nodekey` function.</span>
<span class="sd">        This means, that the user should use this function as well in order to</span>
<span class="sd">        to create a coordinate key prior to looking up the matching values for it.</span>

<span class="sd">    -   **value_field** (str, unicode):</span>

<span class="sd">        The fields to include in the RowLookup dictionary values.</span>
<span class="sd">        These are the values that are returned when you perform a lookup by key.</span>

<span class="sd">    -   **where_clause** (str, unicode, :class:`gpf.tools.queries.Where`):</span>

<span class="sd">        An optional where clause to filter the table.</span>

<span class="sd">    **Keyword params:**</span>

<span class="sd">    -   **duplicate_keys** (bool):</span>

<span class="sd">        If ``True``, the RowLookup allows for duplicate keys in the input.</span>
<span class="sd">        The values will become **lists** of tuples/lists instead of a **single** tuple/list.</span>
<span class="sd">        Please note that duplicate checks will not actually be performed. This means, that</span>
<span class="sd">        when *duplicate_keys* is ``False`` and duplicates are encountered,</span>
<span class="sd">        the last existing key-value pair will be simply overwritten.</span>

<span class="sd">    -   **mutable_values** (bool):</span>

<span class="sd">        If ``True``, the RowLookup values are stored as ``list`` objects.</span>
<span class="sd">        These are mutable, which means that you can change the values or add new ones.</span>
<span class="sd">        The default is ``False``, which causes the RowLookup values to become ``tuple`` objects.</span>
<span class="sd">        These are immutable, which consumes less memory and allows for faster retrieval.</span>

<span class="sd">    :raises RuntimeError:       When the lookup cannot be created or populated.</span>
<span class="sd">    :raises ValueError:         When a specified lookup field does not exist in the source table,</span>
<span class="sd">                                or when a single value field was specified.</span>

<span class="sd">    .. seealso::                When a single field value should be stored in the lookup,</span>
<span class="sd">                                the :class:`gpf.lookups.ValueLookup` class should be used instead.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">key_field</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value_fields</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="n">where_clause</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">_q</span><span class="o">.</span><span class="n">Where</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_vld</span><span class="o">.</span><span class="n">raise_if</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value_fields</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span>
                      <span class="n">f</span><span class="s1">&#39;</span><span class="si">{RowLookup.__name__}</span><span class="s1"> expects multiple value fields: use </span><span class="si">{ValueLookup.__name__}</span><span class="s1"> instead&#39;</span><span class="p">)</span>
        <span class="n">_vld</span><span class="o">.</span><span class="n">pass_if</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">_vld</span><span class="o">.</span><span class="n">has_value</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">table_path</span><span class="p">,</span> <span class="n">key_field</span><span class="p">,</span> <span class="n">value_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="ne">ValueError</span><span class="p">,</span>
                     <span class="n">f</span><span class="s1">&#39;</span><span class="si">{RowLookup.__name__}</span><span class="s1"> requires valid table_path, key_field and value_fields arguments&#39;</span><span class="p">)</span>

        <span class="c1"># User cannot override row processor function for this class</span>
        <span class="k">if</span> <span class="n">_ROWFUNC_ARG</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">_ROWFUNC_ARG</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dupekeys</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_DUPEKEYS_ARG</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rowtype</span> <span class="o">=</span> <span class="nb">list</span> <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">_MUTABLE_ARG</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="nb">tuple</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RowLookup</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">table_path</span><span class="p">,</span> <span class="n">key_field</span><span class="p">,</span> <span class="n">value_fields</span><span class="p">,</span> <span class="n">where_clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fieldmap</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value_fields</span><span class="p">)}</span>

    <span class="k">def</span> <span class="nf">_process_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Row processor function override. &quot;&quot;&quot;</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rowtype</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hascoordkey</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">get_nodekey</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dupekeys</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>

<div class="viewcode-block" id="RowLookup.get_value"><a class="viewcode-back" href="../../gpf.lookups.html#gpf.RowLookup.get_value">[docs]</a>    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks up a value by key for one specific field.</span>
<span class="sd">        This function can be convenient when only a single value needs to be retrieved from the lookup.</span>
<span class="sd">        The difference with the built-in :func:`get` method is, that the :func:`get_value` function</span>
<span class="sd">        returns a single value, whereas the other one returns a list or tuple of values (i.e. row).</span>

<span class="sd">        Example:</span>

<span class="sd">            &gt;&gt;&gt; my_lookup = RowLookup(&#39;C:/Temp/test.gdb/my_table&#39;, &#39;GlobalID&#39;, &#39;Field1&#39;, &#39;Field2&#39;)</span>

<span class="sd">            &gt;&gt;&gt; # Traditional approach to print Field1:</span>
<span class="sd">            &gt;&gt;&gt; values = my_lookup.get(&#39;{628ee94d-2063-47be-b57f-8c2af6345d4e}&#39;)</span>
<span class="sd">            &gt;&gt;&gt; if values:</span>
<span class="sd">            &gt;&gt;&gt;     print(values[0])</span>
<span class="sd">            &#39;ThisIsTheValueOfField1&#39;</span>

<span class="sd">            &gt;&gt;&gt; # Alternative traditional approach to print Field1:</span>
<span class="sd">            &gt;&gt;&gt; field1, field2 = my_lookup.get(&#39;{628ee94d-2063-47be-b57f-8c2af6345d4e}&#39;, (None, None))</span>
<span class="sd">            &gt;&gt;&gt; if field1:</span>
<span class="sd">            &gt;&gt;&gt;     print(field1)</span>
<span class="sd">            &#39;ThisIsTheValueOfField1&#39;</span>

<span class="sd">            &gt;&gt;&gt; # Approach using the get_value() function:</span>
<span class="sd">            &gt;&gt;&gt; print(my_lookup.get_value(&#39;{628ee94d-2063-47be-b57f-8c2af6345d4e}&#39;, &#39;Field1&#39;))</span>
<span class="sd">            &#39;ThisIsTheValueOfField1&#39;</span>

<span class="sd">        :param key:     Key to find in the lookup dictionary.</span>
<span class="sd">        :param field:   The field name (as used during initialization of the lookup) for which to retrieve the value.</span>
<span class="sd">        :param default: The value to return when the value was not found. Defaults to ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">row</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_fieldmap</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">lower</span><span class="p">()]]</span>
        <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span></div></div>


<div class="viewcode-block" id="NodeSet"><a class="viewcode-back" href="../../gpf.lookups.html#gpf.NodeSet">[docs]</a><span class="k">class</span> <span class="nc">NodeSet</span><span class="p">(</span><span class="nb">set</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a set of unique node keys for coordinates in a feature class.</span>
<span class="sd">    The :func:`get_nodekey` function will be used to generate the coordinate hash.</span>
<span class="sd">    When the feature class is Z aware, the node keys will be 3D as well.</span>
<span class="sd">    Note that in all cases, M will be ignored.</span>

<span class="sd">    The ``NodeSet`` inherits all methods from the built-in Python ``set``.</span>

<span class="sd">    For feature classes with a geometry type other than Point, a NodeSet will be built from the first and last</span>
<span class="sd">    points in a geometry. If this is not desired (i.e. all coordinates should be included), the user should set</span>
<span class="sd">    the *all_vertices* option to ``True``.</span>
<span class="sd">    An exception to this behavior is the Multipoint geometry: for this type, all coordinates will always be included.</span>

<span class="sd">    **Params:**</span>

<span class="sd">    -   **fc_path** (str):</span>

<span class="sd">        The full path to the feature class.</span>

<span class="sd">    -   **where_clause** (str, unicode, gpf.tools.queries.Where):</span>

<span class="sd">        An optional where clause to filter the feature class.</span>

<span class="sd">    -   **all_vertices** (bool):</span>

<span class="sd">        Defaults to ``False``. When set to ``True``, all geometry coordinates are included.</span>
<span class="sd">        Otherwise, only the first and/or last points are considered.</span>

<span class="sd">    :raises ValueError:     If the input dataset is not a feature class or if the geometry type is MultiPatch.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fc_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">where_clause</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">_q</span><span class="o">.</span><span class="n">Where</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">all_vertices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populate</span><span class="p">(</span><span class="n">fc_path</span><span class="p">,</span> <span class="n">where_clause</span><span class="p">,</span> <span class="n">all_vertices</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_desc</span><span class="p">(</span><span class="n">fc_path</span><span class="p">):</span>
        <span class="c1"># Checks if the input dataset is valid and returns its Describe object</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">_meta</span><span class="o">.</span><span class="n">Describe</span><span class="p">(</span><span class="n">fc_path</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">desc</span><span class="o">.</span><span class="n">shapeType</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Input dataset {_tu.to_repr(fc_path)} is not a feature class&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">desc</span><span class="o">.</span><span class="n">is_multipatchclass</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Geometry type of {_tu.to_repr(fc_path)} is not supported&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">desc</span>

    <span class="k">def</span> <span class="nf">_fix_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fc_path</span><span class="p">,</span> <span class="n">all_vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tuple of (field, all_vertices) based on the input parameters.</span>
<span class="sd">        The shape type of the feature class sets the field name and may override *oll_vertices*.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The fastest way to fetch results is by reading coordinate tuples</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_desc</span><span class="p">(</span><span class="n">fc_path</span><span class="p">)</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">FIELD_XYZ</span> <span class="k">if</span> <span class="n">desc</span><span class="o">.</span><span class="n">hasZ</span> <span class="k">else</span> <span class="n">_const</span><span class="o">.</span><span class="n">FIELD_XY</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">desc</span><span class="o">.</span><span class="n">is_pointclass</span><span class="p">:</span>
            <span class="c1"># However, for geometry types other than Point, we need to read the Shape object</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">_const</span><span class="o">.</span><span class="n">FIELD_SHAPE</span>
        <span class="k">if</span> <span class="n">desc</span><span class="o">.</span><span class="n">is_multipointclass</span><span class="p">:</span>
            <span class="c1"># Multipoints will be treated differently (always read all vertices)</span>
            <span class="n">all_vertices</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">field</span><span class="p">,</span> <span class="n">all_vertices</span>

    <span class="k">def</span> <span class="nf">_populate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fc_path</span><span class="p">,</span> <span class="n">where_clause</span><span class="p">,</span> <span class="n">all_vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Populates the NodeSet with node keys. &quot;&quot;&quot;</span>

        <span class="n">field</span><span class="p">,</span> <span class="n">all_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fix_params</span><span class="p">(</span><span class="n">fc_path</span><span class="p">,</span> <span class="n">all_vertices</span><span class="p">)</span>

        <span class="c1"># Iterate over all geometries and add keys</span>
        <span class="k">with</span> <span class="n">_cursors</span><span class="o">.</span><span class="n">SearchCursor</span><span class="p">(</span><span class="n">fc_path</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">where_clause</span><span class="p">)</span> <span class="k">as</span> <span class="n">rows</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">shape</span><span class="p">,</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                <span class="c1"># If the geometry is a simple coordinate tuple, immediately add it</span>
                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">_const</span><span class="o">.</span><span class="n">FIELD_XY</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">get_nodekey</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">all_vertices</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">_geo</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">(</span><span class="n">shape</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">get_nodekey</span><span class="p">(</span><span class="o">*</span><span class="n">coord</span><span class="p">))</span>
                    <span class="k">continue</span>

                <span class="c1"># When *all_vertices* is False (or the geometry is not a Multipoint), only get the start/end nodes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">get_nodekey</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">firstPoint</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">get_nodekey</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">lastPoint</span><span class="p">))</span></div>


<div class="viewcode-block" id="ValueSet"><a class="viewcode-back" href="../../gpf.lookups.html#gpf.ValueSet">[docs]</a><span class="k">class</span> <span class="nc">ValueSet</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Builds a set of unique values for a single column in a feature class or table.</span>
<span class="sd">    This class inherits all methods from the built-in Python ``frozenset``.</span>

<span class="sd">    **Params:**</span>

<span class="sd">    -   **table_path** (str):</span>

<span class="sd">        The full path to the table or feature class.</span>

<span class="sd">    -   **field** (str):</span>

<span class="sd">        The field name for which to collect a set of unique values.</span>

<span class="sd">    -   **where_clause** (str, gpf.tools.queries.Where):</span>

<span class="sd">        An optional where clause to filter the feature class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">table_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">where_clause</span><span class="p">:</span> <span class="n">_tp</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">_q</span><span class="o">.</span><span class="n">Where</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Populate the frozenset</span>
        <span class="k">with</span> <span class="n">_cursors</span><span class="o">.</span><span class="n">SearchCursor</span><span class="p">(</span><span class="n">table_path</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">where_clause</span><span class="p">)</span> <span class="k">as</span> <span class="n">rows</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ValueSet</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">))</span>

    <span class="c1"># noinspection PyMissingConstructor, PyUnusedLocal</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_path</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">where_clause</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># This override is only required for type hint purposes and to match __new__&#39;s signature</span>
        <span class="k">pass</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Geocom Informatik AG / VertiGIS, Burgdorf, Switzerland

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>